#计算理论第三次作业
##2016060107001 韦嗣千
1. ***时间复杂度分析样例***
> 题目背景：构造一个长度为2<sup>n</sup>的‘01’串，该‘01’首尾相连形成环状  
从任意位置开始数*n*位构成的数均不相同。

	* 算法思路：
	以0~2<sup>n</sup>-1整数为节点，节点之间的关系是该节点表示的‘01’串去掉最  
高位并分别在末尾加‘0’或‘1’，例如‘010’连向‘101’和‘100’，对建好的图  
跑一遍欧拉回路，即能得出结果。

	* 时间复杂度分析
	每个节点连有两条边，总共有 2<sup>n</sup> 个节点。对这个图进行深度优先遍历，  
	最坏情况下约等于对一颗深度为 2<sup>n</sup>

	* 时间复杂度分析：
	每个节点连有两条边，总共有 2<sup>n</sup>-1 个节点。对这个图进行深度优先遍历，  
	最坏情况下也就是对一棵深度为2<sup>n</sup> 的二叉树遍历，复杂度应为**O(2<sup>2<sup>n</sup></sup>)**。  
	但因为不能出现重复数字，所以通过剪枝,问题变成从剩下的数中取两个，  
	复杂度应降为**O(2<sup>n<sup>2</sup></sup>)**。这个复杂度还是很高，当n=6时，进入递归次数  
	达到了3亿次。  
	**但这个算法就不能用了吗？**
	
	* 有些时候，对于我们分析出来的最坏复杂度，其实是完全达不到的。对于  
	这个具体问题，我们可以发现，以为先递归在末尾加‘0’，复杂度很高，是  
	不是可以反过来想想，先在末尾加‘0’对于这个问题的求解本身就是不利的  
	呢？先加‘1’是不是会好些？
	于是，将dfs里的两个if对调，奇迹出现了。
	当n=6时，程序只递归了66次，通过其它值的实验，发现复杂度应为**O(2<sup>n</sup>)**。
	
	* 最终，复杂度由**O(2<sup>2<sup>n</sup></sup>)**变为 **O(2<sup>n</sup>)**，这是一个质的飞跃。
	
---
附上一小段 C代码：
```c
#include <cstdio>
#include <cmath>
#include <cstring>

int n;
unsigned short int mark[32767];
int size;
unsigned short int higbit(unsigned short int x)
{
	return x>>n<<n;
}
long int time=0;
int dfs(unsigned short int x)
{
	time++;
	if(size==0&&x==1)	return 1;//find
	if(size==0&&x!=1)	return 0;//not find
	unsigned short m0=x<<1,m1=(x<<1)+1;
	m0-=higbit(m0);	m1-=higbit(m1);
	int ans=0;
	if(!mark[m1])
	{
		size--;
		mark[m1]=1;
		ans=dfs(m1);
		if(ans)	{printf("1");	return ans;}
		size++;
		mark[m1]=0;
	}
	if(!mark[m0])
	{
		size--;
		mark[m0]=1;
		ans=dfs(m0);
		if(ans)	{printf("0");	return ans;}
		size++;
		mark[m0]=0;
	}//swap 1 and 0 will occur O(xuan)
	return ans;
}
int main()
{
	scanf("%d",&n);
	size=pow(2,n);
	memset(mark,0,sizeof(mark));
	dfs(1);
	printf("\n进入递归次数：%ld\n",time);
	return 0;
} 
```
---
2. ***空间复杂度分析样例***
> 题目背景：给定一个 1～n 的数列 a 和 b,求每次只交换 a 中相连两  
个元素，最少交换多少次，使 a 变成 b.

	* 算法思路：
	 将 a 中每个元素在 b 中的位置映射成另一个数列 c,问题就变成了求 c 中有  
	 多少对逆序对。也就变成了对 c 进行排序的问题。因为只能交换相连两个  
	 元素，这个过程与冒泡排序是很相似的，但冒泡排序不仅时间复杂度大，  
	 它的空间复杂度就是 n,也没什么好说的，所以我使用归并排序求解逆序对个  
	 数。
	 
	* 空间复杂度分析：
	归并排序在对地规划分求解好的左右两部分进行合并时，需要一个额外的  
	的空间存储合并结果。这一额外的空间可以根据子问题的规模动态分配，但  
	到最后一次合并时两个序列的长度一定是 **n/2**,所以求最坏的空间复杂度自然  
	就取 子序列长度为 **n/2**时。因为还需另一个长度为 n 的序列保存原数列，所  
	以需要的总空间应为 2*n。从归并排序过程中易知，归并排序是一个稳定的  
	过程，它不因 n 的改变为改变程序执行的步骤，所以无所谓最坏的空间复杂   
	度，它的空间复杂度就是 **O(n)**。