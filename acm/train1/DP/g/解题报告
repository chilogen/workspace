#G - 最长上升子序列
> 这个题目本身就是动态规划里的经典问题，都不用做变形，而我提交错误了10次  
都是因为‘最长最小的上升子序列’这句话。

* 最长上升子序列  
	* 定义状态 dp[i]为以 i 为结尾的最长上升子序列长度，状态转移方程为:  
	`d[i]=max{0,d[j]|j<i,aj<ai}+1)` 然后答案为 `max(d[i]);`

* 最长最小的上升子序列
	* 经典问题中并不带路径的记录，更别说`最长最小的上升子序列`，所以我用一个数组   
	`f[i]` 表示 `i` 点的后一点（本来想着这样能比较容易取相同长度下最小的上升  
	子序列，后来发现其实根本不行，然后将 `f[i]` 的含义变成 ‘i’ 点的前一点）。
	
	* 然后，在寻找 `max(d[j]) ` 的时候，记录 最大 `d[j]` 对应的下标`l`,则`f[i]=l`;
	
	* 最后怎么根据 `f[i]` 得到”最长最小的上升子序列“呢？开始我就胡乱写，最后结果也对  
	（当然有一些小问题没有被发现，要不然也不会 RA10）,但我却想不明白结果为什么是  
	对的。
	
	* 过程是这样：从最大的 `d[i] ` 对应的下标开始，也就是`i`,依次将 下标为`f[i]` 的原  
	序列压栈，然后退栈输出，可是为什么这样的道德序列是“最长最小的上升子序列”呢？
	
	* 后来我想明白了，不可能存在这样的 `x1` ,它在另一条相同长度的子序列里，且其大小比将  
	要打印的序列相同位置的`x2`要小。因为如果`x1<x2` 那么他要么在 `x2`的右边，否则它  
	必属于和 `x1` 相同的序列。因为它与`x2`不属于相同序列，所以它在`x2` 左边。而再取   
	`f[i]` 的时候，是由`i-1`到 `0`的方向进行的，也就是从右到左，所以必先取到 `x2`,  
	所以最后的序列一定是 “最长最小的上升子序列”
	
代码：
```c
#include <bits/stdc++.h>
using namespace std;
stack <int> s;
int max(int a,int b)
{
	if(a>b)	return a;
	return b;
}
int main()
{
	//freopen("abc","r",stdin);
	int n,t;
	int a[1001],dp[1001],f[1001];
	int i,j,k,l;
	scanf("%d",&t);
	while(t--)
	{
		memset(dp,0,sizeof(dp));
		memset(f,-1,sizeof(f));
		scanf("%d",&n);
		dp[0]=0;	a[0]=0;
		for(i=1;i<=n;i++)	scanf("%d",&a[i]);
		for(i=1;i<=n;i++)
		{
			k=0;	l=0;
			for(j=i-1;j>0;j--)	
				if(a[j]<a[i]&&dp[j]>k)	
					{k=dp[j];	l=j;}
			dp[i]=max(0,k)+1;
			f[i]=l;
		}
		k=0;
		for(i=n;i>=1;i--)	if(dp[i]>k)	{k=dp[i];	l=i;}
		printf("%d ",k);
		k=-1;
		s.push(a[l]);
		k=f[l];
		while(k!=0)
		{
			s.push(a[k]);
			k=f[k];

		}
		while(!s.empty())
		{
			i=s.top();
			s.pop();
			printf("%d ",i);
		}
		printf("\n");
		//for(i=0;i<=n;i++)	printf("%d ",f[i]);
		//	printf("\n");
	}
	//fclose(stdin);
	return 0;
}
```