#C - “Swap-Plus” puzzle
这道题我没AC ，但我还是交了，希望能拿到这题的数据,找到错在哪。

* 利用stl里的next_permutation生成{0,1,2,3}的全排列，代表行和列24种情况。
* 用两个循环将行和列的24种情况传给move()，实现行列互换只需一个temp数  
组，temp[i][j]=temp[row[i]][col[j]]。
* 遍历temp数组，每发现一个不再正确位置的数字，就将其与它该放的位置存在的  
数互换，同时答案加一。
* 再遍历row和col数组，同样，每发现一个数不再正确位置，就将其放到该放的地  
方，答案加一。
* 所有行和列的情况都算完后，输出最小答案。
* 因为无论先做行变换，还是先做列变换，不影响最终结果，这一思想体现在row和  
col数组上。我实在找不到一组数据证明这段代码是错的，所以能给我发一份数据  
的话，感激不尽。   
1214224883@qq.com
```
#include <bits/stdc++.h>
using namespace std;
int m[4][4];
long long move(int row[4],int col[4])
{
	int i,j,x,y;
	long long ans=0;
	int temp[4][4],c[4],r[4];
	for(i=0;i<4;i++)	for(j=0;j<4;j++)	temp[i][j]=m[row[i]][col[j]];
	//根据row和col数组完成行列交换
	for(i=0;i<4;i++)//计算元素交换次数
	{
		for(j=0;j<4;j++)
		{
			if(temp[i][j]!=4*i+j+1)
			{
				x=(temp[i][j]-1)/4;
				y=(temp[i][j]-1)%4;
				temp[i][j]^=temp[x][y];
				temp[x][y]^=temp[i][j];
				temp[i][j]^=temp[x][y];
				ans++;
			}
		}
		c[i]=col[i];	r[i]=row[i];
	}
	for(i=0;i<4;i++)//计算行列交换次数
	{
		if(r[i]!=i)
		{
			j=r[r[i]];
			r[r[i]]=r[i];
			r[i]=j;
			ans++;
		}
		if(c[i]!=i)
		{
			j=c[c[i]];
			c[c[i]]=c[i];
			c[i]=j;
			ans++;
		}
	}
	return ans;
}
int main()
{
	int temp[4],r[24][4],c[24][4];
	long long ans,min;
	int i,j,k,l;
	for(i=0;i<4;i++)	temp[i]=i;
	j=0;
	do
	{
		for(i=0;i<4;i++)
		{
			r[j][i]=temp[i];
			c[j][i]=temp[i];
		}
		j++;
	}while(next_permutation(temp,temp+4));
	while(scanf("%d%d%d%d",&m[0][0],&m[0][1],&m[0][2],&m[0][3])!=EOF)
	{
		min=9000000000000000;
		for(i=1;i<4;i++)	for(j=0;j<4;j++)	scanf("%d",&m[i][j]);
		for(i=0;i<24;i++)	for(j=0;j<24;j++)
		{
			ans=move(r[i],c[j]);
			min=min>ans?ans:min;
		}
		cout<<min<<endl;
	}
	return 0;
}
```