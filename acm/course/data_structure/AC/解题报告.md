# 第一专题解题报告

## 2016060107001  韦嗣千

*Problem A:*
>  很明显的线段树，维护两个值---Max和Min  
建立线段树后用两个函数 findmax(start,end,root)-findmin(start,end,root)求极差。

*problem C*
> 这题需要使用线段树的lazy标签，本来很早就写出来了，但同样过不了Test1。在做完  
E题后，对造特殊数据有了心得，终于造出个错解，发现同样是溢出。
问题在保存lazy标签时的一条语句：  
`a[x].sum=(a[x].sum+(a[x].right-a[x].left+1)*c)%q;`
在这里，sum 是long long ,本以为不会溢出。但 .right 和 .left是 int ,导致它们运算  
结果也是int,而int明显会超10w*k的值，所以导致体现在sum溢出。这是代码敲得少  
的缘故啊。于是干脆把 int 全部替换为 long long，然后就过了......

*problem*D
>这是个偏序问题。其实是先比较 ***y*** 坐标的大小，如果 ***ay>=by***,再比较 ***x*** 坐标的大小，  
如果 ***ax>=ay*** 则 ***a*** 在 ***b*** 的右上角。  
于是，利用优先队列，以 ***y*** 为第一关键字， ***x*** 为第二关键字排序。依次取出队首元素，  
查询树状数组中 <= 队首元素 ***x*** 坐标的个数，然后再将队首元素 ***x*** 坐标加入树状数组。  
最终输出答案。

*problem E*
> 这是一个求逆序对数的题。将 ***a*** 中元素 在 ***b***中的位置保存于 ***d*** 中，对 ***d***，  
进行归并排序。在左右合并的过程中累加逆序对数。
程序不难写，但写完后一直卡在 test1,自己无论怎么造数据都找不到异常。  
想着Test 1是极限数据，然后发现数组 ***c** 会在 ***a***中值很大时越界，把***c***的定义改为   
`map<long int,long int>`后再提交便通过了。


*problem F:*
> 题目要求按位亦或，所以首先将所有数转化为2进制存储在字符串中，用字符串建树：  
左节点代表‘0’，右节点代表‘1’，使用链表由最高位开始将字符串存与树中。  
使用贪心算法，尽可能把最高位变为‘1’，每向下移动一步将该位亦或结果存于另一  
字符串中，最后将该字符串转化为十进制即为结果。

*problem J*
> 利用STL优先队列---priority_queue,重载运算符改为递减序存储，每次取出队首两个  
元素相加为‘x’，与之前结果‘ans’相加，再将‘x’ push()到队列中去，以 while(q.size>1)  
为循环条件,最后输出答案'ans'。

*problem K*
>使用并查集算法，将删除法力元件看成添加法力元件。初始状态有***0***个并查集  
依次从最后添加法力元件，若该点左端或右端点存在与另一个并查集中，则将这两个并查  
集合并，将两个并查集的值相加存于新并查集的父节点。若改值最大，则将其添加到答案  
序列中，最后将答案序列逆序输出。

*problem L*
> 这是一道加权并查集，三种动物吃与被吃的关系要么组成一条链，要么组成一个环，  
将三种动物关系一一枚举，可以得到某一节点通过其父节点与祖先节点的关系算出其与  
祖先的关系的公式，依据该公式判断是否冲突。

*problem M*
>这题可以利用Set不存在重复元素，且元素按递增排序的特性求解。（ps:当我想利用  
greater<>或重载运算符的方式将其改为递减排序时，再使用 count 和 find 会报错，  
不知道是没写对还是就不能这样用，所以便采用reverse_iterator）。  
同样使用贪心思想，为了凸显老司机功力深厚，也就是最强能力者初始能力最弱，就要  
时刻保持将最大值/2。当迭代到某一值无法缩小或到达 rend()时，输出rbegin()的值。

*problem N*
>又是一道加权并查集问题，两天相同则权值为‘1’不同为‘0’，通过递归关系进行路径压  
缩，判断一对新关系是否存在与并查集中，如果不在，建立一个新的并查集，如果存在，  
判断权值是否矛盾。

*problem P*
>这题涉及的知识点有扫描线和离散化。离散化使用map解决，扫描线的实现使用两棵线  
段树，flag树标记该段是否被选取，wid树记录某段长度。对flag树进行向下更新，而  
`pushup` 的时候只修改wid 树，wid[1]即代表总区间上被覆盖长度，乘与被扫描到的线  
与它顶上一条线的距离，可得这条线与它顶上一条线这个区间的面积，一直累加。因为没  
有清楚意识到多组数据的问题，在每次计算完后没有对清零，导致提交错误完全找不到原  
因......