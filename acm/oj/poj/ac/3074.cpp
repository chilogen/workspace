/*舞蹈链
 * 数据：
 * 4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......
52...6.........7.13...........4..8..6......5...........418.........3..2...87.....
6.....8.3.4.7.................5.4.7.3..2.....1.6.......2.....5.....8.6......1....
48.3............71.2.......7.5....6....2..8.............1.76...3.....4......5....
....14....3....2...7..........9...3.6.1.............8.2.....1.4....5.6.....7.8...
......52..8.4......3...9...5.1...6..2..7........3.....6...1..........7.4.......3.
6.2.5.........3.4..........43...8....1....2........7..5..27...........81...6.....
.524.........7.1..............8.2...3.....6...9.5.....1.6.3...........897........
6..3.2....5.....1..........7.26............543.........8.15........4.2........7..
.6.5.1.9.1...9..539....7....4.8...7.......5.8.817.5.3.....5.2............76..8...
..5...987.4..5...1..7......2...48....9.1.....6..2.....3..6..2.......9.7.......5..
3.6.7...........518.........1.4.5...7.....6.....2......2.....4.....8.3.....5.....
1.....3.8.7.4..............2.3.1...........958.........5.6...7.....8.2...4.......
6..3.2....4.....1..........7.26............543.........8.15........4.2........7..
....3..9....2....1.5.9..............1.2.8.4.6.8.5...2..75......4.1..6..3.....4.6.
45.....3....8.1....9...........5..9.2..7.....8.........1..4..........7.2...6..8..
.237....68...6.59.9.....7......4.97.3.7.96..2.........5..47.........2....8.......
..84...3....3.....9....157479...8........7..514.....2...9.6...2.5....4......9..56
.98.1....2......6.............3.2.5..84.........6.........4.8.93..5...........1..
..247..58..............1.4.....2...9528.9.4....9...1.........3.3....75..685..2...
4.....8.5.3..........7......2.....6.....5.4......1.......6.3.7.5..2.....1.9......
.2.3......63.....58.......15....9.3....7........1....8.879..26......6.7...6..7..4
1.....7.9.4...72..8.........7..1..6.3.......5.6..4..2.........8..53...7.7.2....46
4.....3.....8.2......7........1...8734.......6........5...6........1.4...82......
.......71.2.8........4.3...7...6..5....2..3..9........6...7.....8....4......5....
6..3.2....4.....8..........7.26............543.........8.15........8.2........7..
.47.8...1............6..7..6....357......5....1..6....28..4.....9.1...4.....2.69.
......8.17..2........5.6......7...5..1....3...8.......5......2..4..8....6...3....
38.6.......9.......2..3.51......5....3..1..6....4......17.5..8.......9.......7.32
...5...........5.697.....2...48.2...25.1...3..8..3.........4.7..13.5..9..2...31..
.2.......3.5.62..9.68...3...5..........64.8.2..47..9....3.....1.....6...17.43....
.8..4....3......1........2...5...4.69..1..8..2...........3.9....6....5.....2.....
..8.9.1...6.5...2......6....3.1.7.5.........9..4...3...5....2...7...3.8.2..7....4
4.....5.8.3..........7......2.....6.....5.8......1.......6.3.7.5..2.....1.8......
1.....3.8.6.4..............2.3.1...........958.........5.6...7.....8.2...4.......
1....6.8..64..........4...7....9.6...7.4..5..5...7.1...5....32.3....8...4........
249.6...3.3....2..8.......5.....6......2......1..4.82..9.5..7....4.....1.7...3...
...8....9.873...4.6..7.......85..97...........43..75.......3....3...145.4....2..1
......8.16..2........7.5......6...2..1....3...8.......2......7..3..8....5...4....
.476...5.8.3.....2.....9......8.5..6...1.....6.24......78...51...6....4..9...4..7
.....7.95.....1...86..2.....2..73..85......6...3..49..3.5...41724................
.4.5.....8...9..3..76.2.....146..........9..7.....36....1..4.5..6......3..71..2..
.834.........7..5...........4.1.8..........27...3.....2.6.5....5.....8........1..
..9.....3.....9...7.....5.6..65..4.....3......28......3..75.6..6...........12.3.8
.26.39......6....19.....7.......4..9.5....2....85.....3..2..9..4....762.........4
2.3.8....8..7...........1...6.5.7...4......3....1............82.5....6...1.......
6..3.2....1.....5..........7.26............843.........8.15........8.2........7..
1.....9...64..1.7..7..4.......3.....3.89..5....7....2.....6.7.9.....4.1....129.3.
.........9......84.623...5....6...453...1...6...9...7....1.....4.5..2....3.8....9
.2....5938..5..46.94..6...8..2.3.....6..8.73.7..2.........4.38..7....6..........5
9.4..5...25.6..1..31......8.7...9...4..26......147....7.......2...3..8.6.4.....9.
...52.....9...3..4......7...1.....4..8..453..6...1...87.2........8....32.4..8..1.
53..2.9...24.3..5...9..........1.827...7.........981.............64....91.2.5.43.
1....786...7..8.1.8..2....9........24...1......9..5...6.8..........5.9.......93.4
....5...11......7..6.....8......4.....9.1.3.....596.2..8..62..7..7......3.5.7.2..
.47.2....8....1....3....9.2.....5...6..81..5.....4.....7....3.4...9...1.4..27.8..
......94.....9...53....5.7..8.4..1..463...........7.8.8..7.....7......28.5.26....
.2......6....41.....78....1......7....37.....6..412....1..74..5..8.5..7......39..
1.....3.8.6.4..............2.3.1...........758.........7.5...6.....8.2...4.......
2....1.9..1..3.7..9..8...2.......85..6.4.........7...3.2.3...6....5.....1.9...2.5
..7..8.....6.2.3...3......9.1..5..6.....1.....7.9....2........4.83..4...26....51.
...36....85.......9.4..8........68.........17..9..45...1.5...6.4....9..2.....3...
34.6.......7.......2..8.57......5....7..1..2....4......36.2..1.......9.......7.82
......4.18..2........6.7......8...6..4....3...1.......6......2..5..1....7...3....
.4..5..67...1...4....2.....1..8..3........2...6...........4..5.3.....8..2........
.......4...2..4..1.7..5..9...3..7....4..6....6..1..8...2....1..85.9...6.....8...3
8..7....4.5....6............3.97...8....43..5....2.9....6......2...6...7.71..83.2
....7..8...6...5...2...3.61.1...7..2..8..534.2..9.......2......58...6.3.4...1....
......8.16..2........7.5......6...2..1....3...8.......2......7..4..8....5...3....
.2..........6....3.74.8.........3..2.8..4..1.6..5.........1.78.5....9..........4.
.52..68.......7.2.......6....48..9..2..41......1.....8..61..38.....9...63..6..1.9
....1.78.5....9..........4..2..........6....3.74.8.........3..2.8..4..1.6..5.....
1.......3.6.3..7...7...5..121.7...9...7........8.1..2....8.64....9.2..6....4.....
4...7.1....19.46.5.....1......7....2..2.3....847..6....14...8.6.2....3..6...9....
......8.17..2........5.6......7...5..1....3...8.......5......2..3..8....6...4....
963......1....8......2.5....4.8......1....7......3..257......3...9.2.4.7......9..
15.3......7..4.2....4.72.....8.........9..1.8.1..8.79......38...........6....7423
..........5724...98....947...9..3...5..9..12...3.1.9...6....25....56.....7......6
....75....1..2.....4...3...5.....3.2...8...1.......6.....1..48.2........7........
6.....7.3.4.8.................5.4.8.7..2.....1.3.......2.....5.....7.9......1....
....6...4..6.3....1..4..5.77.....8.5...8.....6.8....9...2.9....4....32....97..1..
.32.....58..3.....9.428...1...4...39...6...5.....1.....2...67.8.....4....95....6.
...5.3.......6.7..5.8....1636..2.......4.1.......3...567....2.8..4.7.......2..5..
.5.3.7.4.1.........3.......5.8.3.61....8..5.9.6..1........4...6...6927....2...9..
..5..8..18......9.......78....4.....64....9......53..2.6.........138..5....9.714.
..........72.6.1....51...82.8...13..4.........37.9..1.....238..5.4..9.........79.
...658.....4......12............96.7...3..5....2.8...3..19..8..3.6.....4....473..
.2.3.......6..8.9.83.5........2...8.7.9..5........6..4.......1...1...4.22..7..8.9
.5..9....1.....6.....3.8.....8.4...9514.......3....2..........4.8...6..77..15..6.
.....2.......7...17..3...9.8..7......2.89.6...13..6....9..5.824.....891..........
3...8.......7....51..............36...2..4....7...........6.13..452...........8..
end
*/

/*issue:
 * sovle()+8,将‘<=’ 换成 '<'执行时间大幅增加
 * solve 执行次数与模板对比：
 *  模板       <           <=
 * 35315    172144      2693490
 * 看不出与模板有多大不同...
 */

/*题解地址：（http://blog.csdn.net/weiguang_123/article/details/7935003）
DLX解决9*9的数独问题，转化为729*324的精确覆盖问题
行：
一共9 * 9 * 9 == 729行。一共9 * 9小格，每一格有9种可能性(1 - 9)，每一种可能都对应着一行。
列：
一共(9 + 9 + 9) * 9 + 81 == 324 种前面三个9分别代表着9行9列和9小块，乘以9的意思是9种可能(1 - 9)，因为每种可能只可以选择一个。
81代表着81个小格，限制着每一个小格只放一个数字。
读入数据后，如果为'.'，则建9行，即有1-9种可能，否则建一行，表示某小格只能放确定的某个数字。
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int INF = 0x7fffffff;
const int NN = 350;
const int MM = 750;
#define N 9
int n,m;    //列，行
int cntc[NN];
int L[NN*MM],R[NN*MM],U[NN*MM],D[NN*MM];//节点的左边，右边，上边，下边
int C[NN*MM];
int head;
int mx[MM][NN];
int O[MM],idx;//删除列及其相应的行
void remove(int c);
int ans[10][10];

//删除列及其相应的行
void remove(int c)
{
    int i,j;
    L[R[c]] = L[c];
    R[L[c]] = R[c];
    for(i = D[c]; i != c; i = D[i])
    {
        for(j = R[i]; j != i; j = R[j])
        {
            U[D[j]] = U[j];
            D[U[j]] = D[j];
            cntc[C[j]]--;
        }
    }
}

//恢复列及其相应的行
void resume(int c)
{
    int i,j;
    R[L[c]] = c;
    L[R[c]] = c;
    for(i = D[c]; i != c; i = D[i])
    {
        for(j = R[i]; j != i; j = R[j])
        {
            U[D[j]] = j;
            D[U[j]] = j;
            cntc[C[j]]++;
        }
    }
}

bool dfs()
{
    int i,j,c;
    if(R[head] == head)
        return true;
    int min = INF;
    for(i = R[head]; i != head; i = R[i])
    {
        if(cntc[i] < min)
        {
            min = cntc[i];
            c = i;
        }
    }
    remove(c);
    for(i = D[c]; i != c; i = D[i])
    {
        //i是某点的序号，将该点所在行的行号保存
        O[idx++] = (i-1)/n;
        for(j = R[i]; j != i; j = R[j])
            remove(C[j]);
        if(dfs())
            return true;
        for(j = L[i]; j != i; j = L[j])
            resume(C[j]);
        idx--;
    }
    resume(c);
    return false;
}

bool build()
{
    int i,j,now,pre,first;
    idx = head = 0;
    for(i = 0; i < n; i++)
    {
        R[i] = i+1;
        L[i+1] = i;
    }
    R[n] = 0;
    L[0] = n;
    //列双向链表
    for(j = 1; j <= n; j++)
    {
        pre = j;
        cntc[j] = 0;
        for(i = 1; i <= m; i++)
        {
            if(mx[i][j])
            {
                cntc[j]++;//j的边数
                now = i*n+j;
                C[now] = j;//C为列指针
                D[pre] = now;
                U[now] = pre;
                pre = now;
            }
        }
        U[j] = pre;
        D[pre] = j;
        if(cntc[j] == 0)
            return false;
    }
    //行双向链表
    for(i = 1; i <= m; i++)
    {
        pre = first = -1;
        for(j = 1; j <= n; j++)
        {
            if(mx[i][j])
            {
                now = i*n+j;
                if(pre == -1)
                    first = now;
                else
                {
                    R[pre] = now;
                    L[now] = pre;
                }
                pre = now;
            }
        }
        if(first != -1)
        {
            R[pre] = first;
            L[first] = pre;
        }
    }
    return true;
}

int T;

void print()
{
    int i,j;
    int x,y,k;
    for(i = 0; i < idx; i++)
    {
        int r = O[i];
        k = r%9;
        if(k==0) k = 9;
        int num = (r - k)/9 + 1;
        y = num%9;
        if(y == 0) y = 9;
        x = (num-y)/9 + 1;
        ans[x][y] = k;
    }
    if(idx == 0)
        printf("impossible\n");
    else
    {
        for(i = 1; i <= 9; i++)
        {
            for(j = 1; j <= 9; j++)
                printf("%d",ans[i][j]);
        }
        cout<<endl;
    }
}

int map[MM][NN];
string str;
void readdata()
{
    char ch;
    int ind=0;
    for(int i = 1; i <= N; i++)
        for(int j = 1; j <= N; j++)
          {
            ch=str[ind++];
            if(ch=='.')
            map[i][j]=0;
            else
            map[i][j]=ch-'0';
          }
}
int main()
{
    int i,j,k;
    int cases;
    char cao[12];
    char s[12][12];
    while(1)
    {
        cin>>str;
        if(str=="end")break;
        memset(mx,0,sizeof(mx));
        readdata();
        for(i = 1; i <= 9; i++)
        {
            for(j = 1; j <= 9; j++)
             {
                int t = (i-1)*9 + j;
                if(map[i][j] == 0)
                {
                    for(k = 1; k <= 9; k++)
                    {
                        mx[9*(t-1)+k][t] = 1;               //81grid 每个小格只能放一个数字
                        mx[9*(t-1)+k][81+(i-1)*9+k] = 1;    //9row 每行数字k只能出现一次
                        mx[9*(t-1)+k][162+(j-1)*9+k] = 1;   //9col  每列数字k只能出现一次
                        mx[9*(t-1)+k][243+((i-1)/3*3+(j+2)/3-1)*9+k] = 1;   //subgrid 每个3*3格子数字k只能出现一次
                    }
                }
                else
                {
                    k = map[i][j];
                    mx[9*(t-1)+k][t] = 1;               //81grid
                    mx[9*(t-1)+k][81+(i-1)*9+k] = 1;    //9row
                    mx[9*(t-1)+k][162+(j-1)*9+k] = 1;   //9col
                    mx[9*(t-1)+k][243+((i-1)/3*3+(j+2)/3-1)*9+k] = 1;   //subgrid
                }
            }
        }
        n = 324;
        m = 729;
        build();
        dfs();
        print();
    }
    return 0;
}
*/

//写挂的DLX
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;
typedef long long LL;

#define MaxNode (5000)
#define MaxColume (81*4+1)
#define Maxans  (1000)

LL v[Maxans][4];
LL ansnum,ans[Maxans];
LL col[MaxNode],row[MaxNode];
LL D[MaxNode],U[MaxNode],L[MaxNode],R[MaxNode];
LL cnt[MaxColume],n=81*4,sz;
LL runtims=0;

inline void encode(LL *v,LL i,LL j,LL k,LL l){
    v[0]=(i-1)*9+k;
    v[1]=81+(j-1)*9+k;
    v[3]=243+(i-1)*9+j;
    i--;j--;
    v[2]=162+(i/3*3+j/3)*9+k;
}
inline LL decode(LL *v,LL &i,LL &j,LL &k){
    LL m,n,o,p,q;
    i=v[0]/9+1;
    j=(v[1]-81)/9+1;
    k=v[0]%9;
    if(k==0){
        k=9;
        i--;
        j--;
    }
}

void putans(){
    LL i,j,k,l;
    char c[11][11];
    memset(c,0,sizeof(c));
    for(l=0;l<ansnum;l++){
        decode(v[ans[l]],i,j,k);
        c[i][j]=k+'0';
    }
    for(i=1;i<=9;i++){
        printf("%s",c[i]+1);
    }
    printf("\n");
}

void del(LL c){
    L[R[c]]=L[c];   R[L[c]]=R[c];
    LL i,j;
    for(i=D[c];i!=c;i=D[i]){
        for(j=R[i];j!=i;j=R[j]){
            D[U[j]]=D[j];   U[D[j]]=U[j];
            cnt[col[j]]--;
        }
    }
}
void restore(LL c){
    L[R[c]]=c;  R[L[c]]=c;
    LL i,j;
    for(i=D[c];i!=c;i=D[i]){
        for(j=R[i];j!=i;j=R[j]){
            D[U[j]]=j;  U[D[j]]=j;
            cnt[col[j]]++;
        }
    }
}
void init(){
    for(sz=0;sz<=n;sz++){
            D[sz]=U[sz]=sz;
            L[sz]=sz-1; R[sz]=sz+1;
            col[sz]=sz;
    }
    L[0]=sz-1;  R[sz-1]=0;
    memset(cnt,0,sizeof(cnt));
}
inline void addRow(LL r,LL *colume){
    LL first=sz,i,j,c;
    for(i=0;i<4;i++){
        c=colume[i];
        col[sz]=c;  row[sz]=r;
        U[sz]=U[c]; D[sz]=c;
        D[U[c]]=sz; U[c]=sz;
        L[sz]=sz-1; R[sz]=sz+1;
        cnt[c]++;   sz++;
    }
    L[first]=sz-1;  R[sz-1]=first;
}
bool solve(LL dep){
    runtims++;
    if(R[0]==0){
        ansnum=dep;
        putans();
        return true;
    }
    LL c=R[0],i,j;
    for(i=R[0];i!=0;i=R[i])if(cnt[i]<=cnt[c])    c=i;

    del(c);
    for(i=D[c];i!=c;i=D[i]){
        ans[dep]=row[i];
        for(j=R[i];j!=i;j=R[j])del(col[j]);
        if(solve(dep+1))return true;
        for(j=R[i];j!=i;j=R[j])restore(col[j]);
    }
    restore(c);
    return false;
}

int main(){
    LL i,j,k,l,m;
    char s[100];
    while(1){
        init();
        scanf("%s",s);m=0;
        if(s[0]=='e')break;
        for(i=1,l=0;i<=9;i++){
            for(j=1;j<=9;j++,m++){
                if(s[m]>='1'&&s[m]<='9'){
                    encode(v[l],i,j,s[m]-'0',0);
                    addRow(l,v[l]);
                    l++;
                    continue;
                }
                for(k=9;k>=1;k--,l++){
                    encode(v[l],i,j,k,1);
                    addRow(l,v[l]);
                }
            }
        }
        solve(0);
    }
    return 0;
}
