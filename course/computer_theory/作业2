#作业二

* **抽象题目描述**
* **初步分析**
* **简单方案**
* **简单方案的复杂度下界分析**
* **进一步分析---小参数特性**
* **改进方案**
* **改进方案的复杂度分析**
* **总结**
* **附代码**

-----

* 抽象题目描述：
给出1000个数，通过最少次询问任意两个位置数的大小关系找到其中最小的10个数。

* 初步分析:
一个简单的想法是:如果能通过询问大小关系将1000个数全部排好序，则很容易在线性时  
间内的到最小的10个数。  

* 简单方案
先不考虑最少次询问，可以将问题转化为排序问题。那么，通过询问不同位置上的数的大  
小关系，能做到排序吗?当然是可以的。我们所熟知的冒泡、选择、归并、快排等，都是  
比较排序算法，通过比较两个元素的大小关系，对元素进行交换，最终达到排序的目的。  
因为最终的目的是要找到最少次询问的方案，所以首先应该排除使用O(n<sup>2</sup>)的排序算法，  
而采用O(nlogn)的快排或归并排序方法。以快排为例，方案描述如下：
```
	假设原数列为 a[n]，设辅助数列b[n]，其中：b[i]=i,即b中保存着位置信息
	query(x,y)----如果a[x]>a[y],为真，否则为假
	
	qsort(l,r)
		mid=partition(l,r)
		qsort(l,mid)
		qsort(mid+1,r)
	
	partition(l,r)
		flag=b[r]
		left=right=l
		while right!=r
			if query(flag,b[right])
				swap(b[left],b[right])
				left=left+1
				right=right+1
			else right=right+1
			
	程序相当与以a中元素大小为关键字，对b进行排序，1~10的位置最终位于b[1~10]
```

* 简单方案的复杂度
首先，需要O(n)的时间设置辅助数列b,然后需要O(**f(n)**)的时间对b排序，最后需要常数时间  
从b中读取答案，因此，总的复杂度为O(n+f(n))。现在需要计算f(n)，f(n)代表**比较排序**算法  
比较排序完成后，每一个元素之间的大小关系都是确定的，所以比较排序的下界就是用最少的  
比较次数确定每一对元素之间的大小关系，可以画出如下一棵树：
![](/home/a/workspace/course/computer_theory/P71107-093454.jpg) 
由树中可知，最少的比较次数就是树的高度，设为h。同时，树的叶子节点是n个数的全排列，  
总共有**n!**个，叶子节点与树高成对数关系，所以h<sub>min</sub>=theta(lg(n!))=theta(nlogn),即  
f(n)=h=omega(nlogn),所以，这个方案的复杂度为O(n+nlogn)=O(lgn)

* 进一步分析--小参数特性
我们可以将问题更泛化一点:从N个数中找到前K个数的位置。  
于是我们有两个参数N和K。很明显，在这个问题中，K为小参数。因此，如果能基于K提出算法，  
将能优化复杂度。

* 改进方案
以K=10为例，假如已经找到在之前询问中出现过的10个最小值，在新的一次询问时，只需要  
确定一个之前未出现过的元素与这10个元素的大小关系，若比这10个数都大，则它永远不可能  
处于解集中，可以直接丢弃，之后也无需再询问。若比这10个数中的任一个数小，则它有可能  
最终会在解集中，而这10个数中的最大那一个则确定不会存在解集中，可以删去。具体方案描  
述如下：
```
	假设原数列为 a[n]，设辅助数列b[n]，其中：b[i].ind=i,即b.ind中保存着位置信息,b[i].next保
	存着比b[i]大的元素的地址,b[i].front保存着比b[i]小的元素的地址
	
	query(x,y)----如果a[x]>a[y],为真，否则为假
	
	T.next=b[1]，b[1].front=T---初始设b[1]位于解集中
	a[0]=-inf,T.ind=0;
	
	for x in b[2~n]
		y=T
		while y-T<=K && y!=NULL
			if query(x.ind,y.ind)	y=y->next
			else
				y.front.next=x
				x.front=y.front
				y.next.front=x
				x.next=y.next
	
	程序相当与用双向链表为基础数据结构，每次插入可能位于解集中的元素，最终结果为T后的K个数据
```

* 改进方案的复杂度分析
同样，需要O(n)的时间预处理b,第一层for的复杂度为O(n),while的复杂度为O(k),链表的插入操  
作视为O(1),所以总的复杂度为O(n+nk)=O(nk),当k为常数时，复杂度为**O(n)**，当k与n同级别  
时，退化为**O(n<sup>2</sup>)**