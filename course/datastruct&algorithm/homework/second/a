#作业二  50-100排队与全排列
#韦嗣千


* 50-100 排队
	* 分析：问题实质为栈的问题，总方案数为**C(2n,n)-C(2n,n-1)**(卡特兰数),可由递归实现
	
	* 求解
	    * 设递归函数`print(k,a,b)`表示安排到第K位是还剩a个50和b个100
	    
	    * 初始条件为`print(0,n,n)`
	    
	    * 当队外存在持有50元的人时（a>0）,无论如何该位置都可以站一个持有50元  
	    的人，当剩余持有100元的人大于持有50元的人时（b>a），该位置可站一个  
	    持有100元的人，所以递归条件为：
```
		if(a>0)	print(k+1,a-1.b);
		if(b>a)	print(k+1,a,b-1);
```

* 全排列问题

	* 方法一：字典序法
	    * 分析：一个字符串的全排列按字典序排列则字典序依次递减（加）1，所以可以从最小  
	    （大）字典序的字符串开始，依次对字典序加（减）的到下一排列
	    
	    * 求解：问题的关键是找到字典序依次递增的字符串的方法。字典序的比较规则最关  
	    键的是**越靠后的元素对字典序影响越小**，`以下所有操作都基于这一点`
	        * 先找到两字符串最靠前的元素不同的位置**k**
	        * 从k往后找到比**a[k]**大的元素中，最小的元素**a[l]**,swap(a[k],a[l])
	        * 将k以后的元素全部逆序
	        * 输出并返回第一步
	        
    * 方法二：递归法
    	* 分析：将一个大的全排列问题分成*确定第一位放什么*+*剩下所有元素的一个小排列问题*  
    	* 求解
    		* 设递归函数`print(n,a,b)`表示对n个元素全排列，已经确定前a个元素，b是当  
    		前排列。
    		* 初始条件为`print(n,0,b)`
    		* 依次选用`b[a--n]`作为当前位置的确定元素，然后求解子问题，递归式为：


```
	for(i=a,i<n;i++)
	{
    		swap(b[i],b[a]);
    		print(n,a+1,b);
    		swap(b[i],b[a]);
	}
```