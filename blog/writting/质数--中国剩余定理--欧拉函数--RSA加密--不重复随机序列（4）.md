#不重复随机数篇

参考：[生成伪随机数的新思路 ——借助RSA算法 ](http://blog.csdn.net/my_xxh/article/details/44836893)

* 朴素算法
  不断生成随机数，没生成一个遍历一遍之前生成的随机数看是否重复，重复则舍弃重新生成，稍微有点改进是  
  增加一个used数组，但缺点是需要生成的随机数范围过大很浪费空间。这种做法的弊病是到最后几乎不可能再  
  生成与之前完全不同的随机数，复杂度O(玄)
 
* 排除算法
每生成一个新的随机数，就把它从之后要生成随机数的范围中刨去，可以使用交换的思想实现：  
预处理：生成一个数列a[n],其中a[i]=i  
*交换方式一：*从开始遍历，每到达一个位置，随机生成另一个随机位置，交换它们的值  
**( swap(a[i],a[rand(i)]) )**
*交换方式二：* 指针p指向数列末尾，每次随机生成（1...p）的随机数x，交换a[x],a[p],同时p减一

  两种方式大同小异，都只需要生成n个随机数，所以复杂度为O(n)

* 公式法
都知道伪随机数的生成来自与一个周期很长的序列，但这个周期不是我们能决定的，所以我们想构造一个周期  
能随意指定的序列。  
加密与编码是两个容易混淆的概念。如果使用错误的解码方式对文本进行解码，就会出现毫无意义的乱码，所  
以有人认为这是一种加密。
加密有一个特点，原文和密文必须是一一对应的，否则加密后将无法解密。而编码，如hash编码，它就不是一  
个一一对应的关系，利用加密的这个特点，如果将一个字符串abcd...加密成a<sub>x</sub>b<sub>x</sub>c<sub>x</sub>d<sub>x</sub>...对应成范围abcd...的  
随机序列，就实现了生成不重复随机序列的目的
利用[rsa加密](http://blog.csdn.net/lftuui/article/details/78071240) 生成不重复随机序列：
